# 常量池解析
- Java字节码常量池的内存分配链路
- oop-klass模型
- 常量池的解析原理

> 在字节码文件中，常量池的字节码流所在的块区紧跟在魔数和版本号之后，因此JVM在解析完魔数与版本号后就开始解析常量池。JVM解析Java类字节码文件的接口：ClassFileParser::parseClassFile(),总体步骤如下：解析魔数-->解析版本号-->解析常量池-->解析父类-->解析接口-->解析类变量-->解析类方法-->构建类结构。JVM解析常量池信息主要链路:ClassFileParser::parseClassFile()-->ClassFileParser::parse_constant_pool()-->oopFactory::new_constantPool()（分配常量池内存）；ClassFileParser::parse_constant_pool_entries()(解析常量池信息)。

## 常量池内存分配
### 常量池内存分配总体链路

- ClassFileParser::parse_constant_pool()函数中，通过以下代码实现常量池内存分配：

```
onstantPoolOop constant_pool = oopFactory::new——constantPool(length,oopDesc::IsSafeConc,CHECK_(nullHandle));
```
- length:代表当前字节码文件的常量池中一共包含多少个常量池元素，由Java编译器在编译期间通过计算得出，保存在字节码文件中。

oopFactory::new_constantPool()的链路比较长，下图展示了总体调用路径：
常量池内存分配链路.png

- oopFactory：oop的工厂类，JVM内部，查了那个量尺、字段、符号、方法等一切都被对象包装起来，在内存中通过oop指针进行跟踪，而这些对象的内存分配、对象创建与初始化工作都通过oopFactory这个入口实现。
- constantPoolKlass：常量池类型对象。JVM内部预留的一段描述常量池结构信息的内存。
- collectedHeap：JVM内部的堆内存区域，可被垃圾收集器回收并反复利用。其代表JVM内部广义的堆内存区域。除了堆栈变量之外的一切内存分配都需要经过本区域。
- psPermGen：表示perm区内存，JDK1.6版本产物，Java类的字节码信息会保存到这块区域，JDK1.8后，perm去概念被metaSpace概念取代。
> perm指内存的永久保存区域，这一部分用于存放Class和Meta的信息，Class在被加载的时候放入permGen space区域，如果加载了太多类就很可能出现PermGen space错误。而在metaSpace时代，这块区域是属于“本地内存”区域，也就是操作系统，相对于JVM虚拟机内存而言的，JVM直接向操作系统申请内存存储Java类的袁茜茜，如此一来可以解决为permGen space指定的内存太小而导致perm区内存耗尽的问题。

**从宏观层面上看，常量池内存分配大体上可以分为以下三步：**
- 在堆区分配内存空间
- 初始化对象
- 初始化oop

### 内存分配
> 从oopFactory::new_constantPool()调用开始，到mutableSpace:allocate()的过程可认为是第一阶段，即为constantPool申请内存。

-JVM为constantPool申请内存链路
- oopFactory.cpp(ck->allocate(length,is_conc_safe,CHECK_NULL))
- constantPoolKlass.cpp(CollectedHeap::permanent_obj_allocate(klass, size, CHECK_NULL))
- collectedHeap.inline.hpp(permanent_obj_allocate_no_klass_install(klass,size,CHECK_NULL))
- collectedHeap.inline.hpp(common_permanent_men_allocate_init(size,CHECK_NULL))
- collectedHeap.inline.hpp(common_permanent_men_allocate_noinit(size,CHECK_NULL))
- collectedHeap.inline.hpp(Universe::heap()->permanent_men_allocate(size))
- parallelScavengeHeap.cpp(perm_gen()->allocate_permanent(size))
- psPermGen.cpp(allocate_noexpand(size,false))
- paOldGen.hpp(objec_space()->allocate(word_size))

内存申请最终通过objec_space()->allocate(word_size)实现，定义如下：

```
HeapWord* MutableSpace::allocate(size_t size) {
  assert(Heap_lock->owned_by_self() ||
         (SafepointSynchronize::is_at_safepoint() &&
          Thread::current()->is_VM_thread()),
         "not locked");
  HeapWord* obj = top();
  if (pointer_delta(end(), obj) >= size) {
    HeapWord* new_top = obj + size;
    set_top(new_top);
    assert(is_object_aligned((intptr_t)obj) && is_object_aligned((intptr_t)new_top),
           "checking alignment");
    return obj;
  } else {
    return NULL;
  }
}
```
- 通过HeapWord* new_top = obj + size;将permSpace内存区域的top指针往高地址方向移动了size大小的字节数，完成了内存分配（仅仅从JVM申请的堆内存中划拨了一块空间用于存储常量池结构信息）
- 先执行HeapWord* obj = top();然后执行HeapWord* new_top = obj + size;返回的仍是原堆顶obj指针，可以通过指针还原从原堆顶到当前堆顶之间的内存空间，将其强转型为常量池对象。
- JVM在启动过程中完成permSpace的内存申请和初始化，每次新写入一个对象，该对象的内存首地址便是写入之前top指针所指位置。

#### constantPool的内存有多大
> 为一个Java类创建其对应的常量池，需要在JVM堆区为常量池先申请一块连续空间，所申请的空间大小取决于一个Java类在编译时所确定的常量池大小（size），在常量池初始化链路中调用constantPoolKlass::allocate()方法，这个方法会调用constantPoolOopDesc::object_size(length)方法获取常量池大小，方法原型：


```
 static int header_size()             { return sizeof(constantPoolOopDesc)/HeapWordSize; }
 static int object_size(int length)   { return align_object_size(header_size() + length); }
```
> object_size()的逻辑十分简单，就是将header_size和length相加后进行内存对齐。header_size（）返回的是constantPoolOopDesc类型的大小。align_object_size()是实现内存对齐，便于GC进行工作时更加高效。在32位操作系统上，HeapWordSize大小为4，是一个指针变量的长度，在32位平台上sizeof(constantPoolOopDesc)返回40.

##### 关于sizeof
> 当计算C++类时，返回的是其所有变量的大小加上虚函数指针大小，若在类中定义了普通函数，都不会计算其大小。


```
#include<stdio.h>

class A {
private:
	char* a;
public:
	int getA() {
		return 1;
	}
};

int main() {
	printf("sizeof(A)=%d\n", sizeof(A));
	return 0;
}
```
**这一段程序在32位系统输出是4,64位系统输出为8，因为他只包含一个char型指针变量。如此一来我们可以推算sizeof(constantPoolOopDesc)的返回值大小**
constantPoolOopDesc本身包含8个字段
- typeArrayOop           _tags
- constantPoolCacheOop   _cache
- klassOop               _pool_holder
- typeArrayOop           _operands
- int                    _flags
- int                    _length
- volatile bool          _is_conc_safe
- int                    _orig_length

而由于constantPoolOopDesc继承自oopDesc类，因此还会包含父类的成员变量：

```
volatile markOop _mark;     //指针
union _metadata{            //指针
    wideKlassOop _klass;
    narrowOop _compressed_klass;
}_metadata;
```
- 所以，constantPoolOopDesc最终包含10个字段，在32位平台上占40字节。
我们接下来在看HeapWordSize的定义：

```
const int HeapWordSize        = sizeof(HeapWord);
class HeapWord {
  friend class VMStructs;
 private:
  char* i;
#ifndef PRODUCT
 public:
  char* value() { return i; }
#endif
};
```
> 可以看到，HeapWordSize就是一个char*类型的大小，在32位平台是4,64位平台是8，所以return sizeof(constantPoolOopDesc)/HeapWordSize;返回的就是constantPoolOopDesc类型本身所占内存的总字节数。所以最终constantPoolKlass::allocate()从JVM堆中所申请的内存空间大小包含：constantPoolOopDesc大小和Java类常量池元素数量。

我们来举一个例子：

```
public class Iphone6S {
    int length = 138;
    int width = 67;
    int height = 7;
    int weight = 142;
    int ram = 2;
    int rom = 16;
    int pixel = 1200;
}
```
字节码中显示常量池大小为0x0023，对应十进制35，因此常量池一共包含38个元素，再看javap反编译的信息：

```
Constant pool:
   #1 = Methodref          #10.#25        // java/lang/Object."<init>":()V
   #2 = Fieldref           #9.#26         // JVM/Iphone6S.length:I
   #3 = Fieldref           #9.#27         // JVM/Iphone6S.width:I
   #4 = Fieldref           #9.#28         // JVM/Iphone6S.height:I
   #5 = Fieldref           #9.#29         // JVM/Iphone6S.weight:I
   #6 = Fieldref           #9.#30         // JVM/Iphone6S.ram:I
   #7 = Fieldref           #9.#31         // JVM/Iphone6S.rom:I
   #8 = Fieldref           #9.#32         // JVM/Iphone6S.pixel:I
   #9 = Class              #33            // JVM/Iphone6S
  #10 = Class              #34            // java/lang/Object
  #11 = Utf8               length
  #12 = Utf8               I
  #13 = Utf8               width
  #14 = Utf8               height
  #15 = Utf8               weight
  #16 = Utf8               ram
  #17 = Utf8               rom
  #18 = Utf8               pixel
  #19 = Utf8               <init>
  #20 = Utf8               ()V
  #21 = Utf8               Code
  #22 = Utf8               LineNumberTable
  #23 = Utf8               SourceFile
  #24 = Utf8               Iphone6S.java
  #25 = NameAndType        #19:#20        // "<init>":()V
  #26 = NameAndType        #11:#12        // length:I
  #27 = NameAndType        #13:#12        // width:I
  #28 = NameAndType        #14:#12        // height:I
  #29 = NameAndType        #15:#12        // weight:I
  #30 = NameAndType        #16:#12        // ram:I
  #31 = NameAndType        #17:#12        // rom:I
  #32 = NameAndType        #18:#12        // pixel:I
  #33 = Utf8               JVM/Iphone6S
  #34 = Utf8               java/lang/Object
```
JVM会保留0号常量池位置，所以只有34个元素。按照上面分析，JVM会从permSpace中划分（40+35）*4字节的内存大小（32位平台）。

#### 内存空间布局
> JVM为常量池对象申请的内存位于perm区，perm区本事是一片连续的内存区域，而JVM为常量池申请内存时也是正片区域连续划分，因此每一个constantPoolOop对象实例在perm区中都是连续分布的，不会存在碎片化。

> 最终申请好的空间布局如图ConstantPoolOop内存布局.png所示（假设运行于Linux32位平台，指针宽度为4字节，并且常量池分配方向从低地址到高地址。JVM内部为对象分配内存时，先分配对象头，然后分配对象的实例数据，不管字段对象还是方法对象亦或是数组，都是如此。

#### 初始化内存
> JVM为Java类所对应的常量分配好内存空间后，接着需要对这段内存空间进行初始化（实际上是清零操作）。在Linux32位平台上最终调用pd_fill_to_words()函数，声明如下：


```
static void pd_fill_to_words(HeapWord* tohw, size_t count, juint value) {
#ifdef AMD64
  julong* to = (julong*) tohw;
  julong  v  = ((julong) value << 32) | value;
  while (count-- > 0) {
    *to++ = v;
  }
#else
  juint* to = (juint*)tohw;
  count *= HeapWordSize / BytesPerInt;
  while (count-- > 0) {
    *to++ = value;
  }
#endif // AMD64
}
```
> 可以看到这个函数有3个入参，会将指定内存区的内存数据全部清空为value值，在CollectedHeap::init_obj()中调用了Copy::fill_to_aligned_words(obj+hs,size-hs)函数，而Copy::fill_to_aligned_words()函数有三个入参，声明如下：

```
  static void fill_to_aligned_words(HeapWord* to, size_t count, juint value = 0) {
    assert_params_aligned(to);
    pd_fill_to_aligned_words(to, count, value);
  }
```
**该函数第三个参数默认为0，所以在执行pd_fill_to_aligned_words（）函数时，指定的内存区会全部清零。

### oop-klass模型
#### 两模型三维度
> JVM内部基于oop-klass模型描述一个Java类，将一个Java类一拆为二，分别描述，第一个模型是oop，第二个模型是klass。所谓oop，实际上是指ordinary object pointer（普通对象指针），用来表示对象的实例信息，看起来像个指针，实际上对象实例数据都藏在指针所指向的内存首地址后面的一片内存区域中。而klass则包含元数据和方法信息，用来描述Java类或者JVM内部自带的C++类型信息，**Java类的继承信息、成员变量、静态变量、成员方法、构造函数等信息都在klass中保存。JVM由此便可以在运行期反射出Java类的全部结构信息。**

- oop模型：侧重于描述Java类的实例数据，为Java类生成一张“实例数据视图”，从数据维度描述一个Java类实例对象中各属性在运行期的值
- klass模型
    * Java类的“元信息视图”，为JVM在运行期呈现Java类的全息数据结构信息，**是JVM在运行期的移动台反射出类信息的基础。**
    * 虚函数列表（方法分发规则）
    
> tip:Java类的所有函数都视为是“virtual”的，这样Java类的每个方法都可以直接被其子类覆盖而不需要添加任何关键字作为修饰符，因此，**Java类中的每个方法都可以晚绑定**，而也正是因为所有函数都视为虚函数，所以在JVM内部的C++就必须维护一套函数分发表。

#### 体系总览
oop klass handle的三角关系.png
> handle是对oop的行为的封装，在访问Java类时，一定是通过handle内部指针得到oop示例的，在通过oop就能拿到klass，如此handle最终便能操纵oop的行为了。
Handle类的基本结构：

```
class Handle VALUE_OBJ_CLASS_SPEC {
 private:
  oop* _handle;
//省略部分代码
};
```
> 可以看到Handle内部只有一个成员变量_handle指向oop类型，因此该变量指向的是一个oop首地址。oop一般由对象头、对象专有属性和数据体三部分构成，结构如图
oop模型.png
> JVM内部定义了若干oop类型，每一种oop类型都有自己特有的数据结构，oop的专有属性区便是用于存放各个oop所特有的数据结构的地方。

#### oop体系
究竟什么是普通对象指针？
- Hotspot里的oop指什么
> Hotspot里的oop其实就是GC所托管的指针，所有oopDesc及其子类（除了markOopDesc外）的实例都是由GC所管理
- 对象指针前为何冠以“普通”二字
> 在HotSpot里面，oop就是指一个真正的指针，而markOop则是一个看起来像指针，实际上是藏在指针里面的对象（数据），并没有指向内存的功能，这也正是它不受GC托管的原因，只要除了函数作用域，指针变量就会直接从堆栈上释放，不需要垃圾回收了。

oop的继承体系：

```
typedef class oopDesc*                            oop;                  //所有oop顶级父类
typedef class   instanceOopDesc*            instanceOop;                //表示Java类实例
typedef class   methodOopDesc*                    methodOop;            //表示Java方法
typedef class   constMethodOopDesc*            constMethodOop;          //表示Java方法中的只读信息（字节码指令）
typedef class   methodDataOopDesc*            methodDataOop;            //表示性能统计的相关数据
typedef class   arrayOopDesc*                    arrayOop;              //表示数组对象
typedef class     objArrayOopDesc*            objArrayOop;              //表示引用类型数组对象
typedef class     typeArrayOopDesc*            typeArrayOop;            //表示基本类型数组对象
typedef class   constantPoolOopDesc*            constantPoolOop;        //表示Java字节码文件中的常量池
typedef class   constantPoolCacheOopDesc*   constantPoolCacheOop;       //与constantPoolOop伴生，是后者的缓存对象
typedef class   klassOopDesc*                    klassOop;              //指向JVM内部的klass实例的对象
typedef class   markOopDesc*                    markOop;                //oop的标记对象
typedef class   compiledICHolderOopDesc*    compiledICHolderOop;
```

#### klass体系
- klass提供一个与Java类对等的C++类型描述
- klass提供虚拟机内部的函数分发机制

klass的继承体系：

```
class Klass;                                //klass家族基类
class   instanceKlass;                      //虚拟机层面上与Java类对等的数据结构
class     instanceMirrorKlass;              //描述java.lang.Class的实例
class     instanceRefKlass;                 //描述java.lang.ref.Reference的子类
class   methodKlass;                        //表示Java类的方法
class   constMethodKlass;                   //描述Java类方法所对应的字节码指令信息的固有属性
class   methodDataKlass;                    
class   klassKlass;                         //klass链路末端，在jdk8中已经不存在
class     instanceKlassKlass;               
class     arrayKlassKlass;
class       objArrayKlassKlass;
class       typeArrayKlassKlass;
class   arrayKlass;                         //描述Java数组的信息，是抽象基类
class     objArrayKlass;                    //描述Java引用类型数组的数据结构
class     typeArrayKlass;                   //描述Java中基本类型数组的数据结构
class   constantPoolKlass;                  //描述Java字节码文件中的常量池的数据结构
class   constantPoolCacheKlass;
class   compiledICHolderKlass;
```

基类klass定义：

```
class Klass : public Klass_vtbl {
  friend class VMStructs;
 protected:
 
  enum { _primary_super_limit = 8 };
  jint        _layout_helper;
  juint       _super_check_offset;
  Symbol*     _name;

 public:
  oop* oop_block_beg() const { return adr_secondary_super_cache(); }
  oop* oop_block_end() const { return adr_next_sibling() + 1; }

 protected:
  klassOop    _secondary_super_cache;
  objArrayOop _secondary_supers;
  klassOop    _primary_supers[_primary_super_limit];
  oop       _java_mirror;
  klassOop  _super;
  klassOop _subklass;
  klassOop _next_sibling;

  //
  // End of the oop block.
  //
  jint        _modifier_flags;  // Processed access flags, for use by Class.getModifiers.
  AccessFlags _access_flags;    // Access flags. The class/interface distinction is stored here.
  juint    _alloc_count;        // allocation profiling support - update klass_size_in_bytes() if moved/deleted

  // Biased locking implementation and statistics
  // (the 64-bit chunk goes first, to avoid some fragmentation)
  jlong    _last_biased_lock_bulk_revocation_time;
  markOop  _prototype_header;   // Used when biased locking is both enabled and disabled for this type
  jint     _biased_lock_revocation_count;
  //省略部分代码
};
```
字段名|含义
---|---|
_layout_helper|对象布局的综合描述符
_name|类名，如java/lang/String
_java_mirror|类的镜像类
_super|父类
_subklass|指向第一个子类
_next_sibling|指向下一个兄弟结点
_modifier_flags|修饰符标识，如static
_access_flags|访问权限标识，如public

- 如果一个KLASS既不是instance也不是array，则_layout_helper被设置为0，若是instance，则为正数，若是数组，则为负数。

